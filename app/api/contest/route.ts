// Market Oracle - Contest System API
// Quarterly stock picking competitions
// Q1 2025 Contest Launch: January 1, 2025

import { NextResponse } from 'next/server';

const FINNHUB_API_KEY = process.env.FINNHUB_API_KEY;

interface Contest {
  id: string;
  name: string;
  description: string;
  startDate: string;
  endDate: string;
  status: 'upcoming' | 'active' | 'completed';
  prize: string;
  entryFee: number;
  maxPicks: number;
  participants: number;
  rules: string[];
}

interface ContestEntry {
  odaycontestId: string;
  odayuserId: string;
  odaypicks: Array<{
    symbol: string;
    entryPrice: number;
    currentPrice: number;
    change: number;
    changePercent: number;
    pickedAt: string;
  }>;
  totalReturn: number;
  rank: number;
}

// Contest definitions
const CONTESTS: Contest[] = [
  {
    id: 'q1-2025',
    name: 'Q1 2025 AI Stock Challenge',
    description: 'Pick 5 stocks to beat the AI models. Top performers win prizes!',
    startDate: '2025-01-01T00:00:00Z',
    endDate: '2025-03-31T23:59:59Z',
    status: 'upcoming',
    prize: '$1,000 in credits + Premium subscription',
    entryFee: 0,
    maxPicks: 5,
    participants: 0,
    rules: [
      'Pick exactly 5 stocks before January 1, 2025',
      'Stocks must be US-listed with $1B+ market cap',
      'No penny stocks or OTC securities',
      'Performance measured by total return',
      'AI models compete alongside human participants',
      'Top 10 performers win prizes'
    ]
  },
  {
    id: 'q2-2025',
    name: 'Q2 2025 AI Stock Challenge',
    description: 'Spring quarter competition - Can you beat Claude and GPT-4?',
    startDate: '2025-04-01T00:00:00Z',
    endDate: '2025-06-30T23:59:59Z',
    status: 'upcoming',
    prize: '$1,500 in credits + Premium subscription',
    entryFee: 0,
    maxPicks: 5,
    participants: 0,
    rules: [
      'Pick exactly 5 stocks before April 1, 2025',
      'Stocks must be US-listed with $1B+ market cap',
      'No penny stocks or OTC securities',
      'Performance measured by total return',
      'AI models compete alongside human participants',
      'Top 10 performers win prizes'
    ]
  }
];

// AI Models as contestants
const AI_CONTESTANTS = [
  { id: 'claude-ai', name: 'Claude AI', model: 'claude-3-5-sonnet', avatar: 'ðŸ¤–', tier: 'premium' },
  { id: 'gpt4-ai', name: 'GPT-4', model: 'gpt-4o', avatar: 'ðŸ§ ', tier: 'premium' },
  { id: 'gemini-ai', name: 'Gemini', model: 'gemini-1.5-flash', avatar: 'âœ¨', tier: 'standard' },
  { id: 'llama-ai', name: 'Llama 3.1', model: 'llama-3.1-70b', avatar: 'ðŸ¦™', tier: 'standard' },
  { id: 'perplexity-ai', name: 'Perplexity', model: 'pplx-70b', avatar: 'ðŸ”®', tier: 'standard' },
  { id: 'mistral-ai', name: 'Mistral', model: 'mistral-large', avatar: 'ðŸ’¨', tier: 'standard' },
];

// Sample AI picks for Q1 2025 (would be generated by actual AI calls)
const AI_PICKS: Record<string, string[]> = {
  'claude-ai': ['NVDA', 'META', 'GOOGL', 'AMZN', 'MSFT'],
  'gpt4-ai': ['AAPL', 'NVDA', 'TSLA', 'AMD', 'AVGO'],
  'gemini-ai': ['NVDA', 'AAPL', 'META', 'CRM', 'NOW'],
  'llama-ai': ['MSFT', 'GOOGL', 'AMZN', 'NFLX', 'AMD'],
  'perplexity-ai': ['NVDA', 'PLTR', 'SNOW', 'DDOG', 'NET'],
  'mistral-ai': ['META', 'NVDA', 'TSLA', 'COIN', 'SQ'],
};

async function fetchStockPrice(symbol: string): Promise<number | null> {
  if (!FINNHUB_API_KEY) return null;
  try {
    const res = await fetch(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`);
    if (!res.ok) return null;
    const data = await res.json();
    return data.c || null;
  } catch { return null; }
}

async function calculateContestStandings(contestId: string): Promise<any[]> {
  const standings: any[] = [];
  
  // Calculate AI standings
  for (const ai of AI_CONTESTANTS) {
    const picks = AI_PICKS[ai.id] || [];
    let totalReturn = 0;
    const pickDetails: any[] = [];
    
    for (const symbol of picks) {
      const currentPrice = await fetchStockPrice(symbol);
      // Simulated entry prices (would come from database)
      const entryPrice = currentPrice ? currentPrice * (1 - Math.random() * 0.1 + 0.05) : 100;
      const change = currentPrice ? currentPrice - entryPrice : 0;
      const changePercent = entryPrice ? (change / entryPrice) * 100 : 0;
      
      totalReturn += changePercent;
      pickDetails.push({
        symbol,
        entryPrice: Math.round(entryPrice * 100) / 100,
        currentPrice: currentPrice || 0,
        change: Math.round(change * 100) / 100,
        changePercent: Math.round(changePercent * 100) / 100
      });
    }
    
    standings.push({
      odayid: ai.id,
      name: ai.name,
      avatar: ai.avatar,
      tier: ai.tier,
      isAI: true,
      picks: pickDetails,
      totalReturn: Math.round((totalReturn / picks.length) * 100) / 100,
      rank: 0
    });
  }
  
  // Sort by return and assign ranks
  standings.sort((a, b) => b.totalReturn - a.totalReturn);
  standings.forEach((s, i) => { s.rank = i + 1; });
  
  return standings;
}

function getContestStatus(contest: Contest): 'upcoming' | 'active' | 'completed' {
  const now = new Date();
  const start = new Date(contest.startDate);
  const end = new Date(contest.endDate);
  
  if (now < start) return 'upcoming';
  if (now > end) return 'completed';
  return 'active';
}

function getTimeRemaining(contest: Contest): string {
  const now = new Date();
  const start = new Date(contest.startDate);
  const end = new Date(contest.endDate);
  
  const status = getContestStatus(contest);
  
  if (status === 'upcoming') {
    const diff = start.getTime() - now.getTime();
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    return `Starts in ${days}d ${hours}h`;
  } else if (status === 'active') {
    const diff = end.getTime() - now.getTime();
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    return `${days} days remaining`;
  }
  return 'Contest ended';
}

export async function GET(request: Request) {
  const startTime = Date.now();
  const { searchParams } = new URL(request.url);
  const action = searchParams.get('action') || 'list';
  const contestId = searchParams.get('contestId') || 'q1-2025';
  
  try {
    switch (action) {
      case 'list': {
        // List all contests
        const contests = CONTESTS.map(c => ({
          ...c,
          status: getContestStatus(c),
          timeRemaining: getTimeRemaining(c)
        }));
        
        return NextResponse.json({
          success: true,
          timestamp: new Date().toISOString(),
          contests,
          activeContest: contests.find(c => c.status === 'active') || contests.find(c => c.status === 'upcoming'),
          aiContestants: AI_CONTESTANTS.length,
          totalPrizePool: contests.reduce((sum, c) => sum + (c.prize.includes('$') ? parseInt(c.prize.match(/\$(\d+)/)?.[1] || '0') : 0), 0)
        });
      }
      
      case 'standings': {
        // Get contest standings
        const contest = CONTESTS.find(c => c.id === contestId);
        if (!contest) {
          return NextResponse.json({ success: false, error: 'Contest not found' }, { status: 404 });
        }
        
        const standings = await calculateContestStandings(contestId);
        
        return NextResponse.json({
          success: true,
          timestamp: new Date().toISOString(),
          processingTime: `${Date.now() - startTime}ms`,
          contest: {
            ...contest,
            status: getContestStatus(contest),
            timeRemaining: getTimeRemaining(contest)
          },
          standings,
          topPerformer: standings[0],
          averageReturn: Math.round(standings.reduce((sum, s) => sum + s.totalReturn, 0) / standings.length * 100) / 100
        });
      }
      
      case 'details': {
        // Get specific contest details
        const contest = CONTESTS.find(c => c.id === contestId);
        if (!contest) {
          return NextResponse.json({ success: false, error: 'Contest not found' }, { status: 404 });
        }
        
        return NextResponse.json({
          success: true,
          timestamp: new Date().toISOString(),
          contest: {
            ...contest,
            status: getContestStatus(contest),
            timeRemaining: getTimeRemaining(contest)
          },
          aiContestants: AI_CONTESTANTS,
          aiPicks: Object.entries(AI_PICKS).map(([id, picks]) => ({
            contestant: AI_CONTESTANTS.find(a => a.id === id),
            picks
          }))
        });
      }
      
      case 'ai-picks': {
        // Get all AI picks for a contest
        const picks = await Promise.all(
          AI_CONTESTANTS.map(async (ai) => {
            const symbols = AI_PICKS[ai.id] || [];
            const pricesPromises = symbols.map(s => fetchStockPrice(s));
            const prices = await Promise.all(pricesPromises);
            
            return {
              ai: ai.name,
              avatar: ai.avatar,
              picks: symbols.map((s, i) => ({
                symbol: s,
                currentPrice: prices[i] || 0
              }))
            };
          })
        );
        
        return NextResponse.json({
          success: true,
          timestamp: new Date().toISOString(),
          processingTime: `${Date.now() - startTime}ms`,
          contestId,
          aiPicks: picks
        });
      }
      
      default:
        return NextResponse.json({
          success: false,
          error: 'Invalid action',
          validActions: ['list', 'standings', 'details', 'ai-picks']
        }, { status: 400 });
    }
  } catch (error) {
    console.error('Contest API error:', error);
    return NextResponse.json({
      success: false,
      error: 'Failed to process contest request',
      message: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}

// POST endpoint for user entries (future implementation)
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { action, contestId, userId, picks } = body;
    
    // For now, return a placeholder response
    // Full implementation would connect to Supabase
    return NextResponse.json({
      success: true,
      message: 'Entry received',
      note: 'Full user entry system coming soon. Connect with Supabase for persistence.',
      entry: {
        contestId,
        userId,
        picks,
        submittedAt: new Date().toISOString()
      }
    });
  } catch (error) {
    return NextResponse.json({
      success: false,
      error: 'Failed to process entry'
    }, { status: 500 });
  }
}
